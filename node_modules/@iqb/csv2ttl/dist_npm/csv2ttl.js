#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var config_file_factory_1 = require("./config-file.factory");
var csv_factory_1 = require("./csv.factory");
require('fs');
var dataFolder = '.';
if (process.argv[2]) {
    dataFolder = "".concat(dataFolder, "/").concat(process.argv[2]);
}
function getNotationDeep(notation) {
    var firstLevel = notation.split(' ').length;
    if (firstLevel > 1) {
        return notation.split('.').length + 1;
    }
    return Math.max(1, notation.split('.').length);
}
var configData = config_file_factory_1.ConfigFileFactory.load(dataFolder);
if (configData) {
    var outputFolder_1 = '.';
    if (configData.outDir) {
        outputFolder_1 = configData.outDir;
        if (!fs.existsSync(outputFolder_1)) {
            fs.mkdirSync(outputFolder_1);
        }
    }
    var fileList_1 = {};
    fs.readdirSync(dataFolder).forEach(function (file) {
        fileList_1[file.toUpperCase()] = "".concat(dataFolder, "/").concat(file);
    });
    var csvDelimiter_1 = configData.csv_delimiter || ';';
    var stoutBase_1 = '@prefix dct: <http://purl.org/dc/terms/>.\n' +
        '@prefix skos: <http://www.w3.org/2004/02/skos/core#>. \n' +
        '@prefix dc: <http://purl.org/dc/elements/1.1/>.\n' +
        "@prefix n0: <".concat(configData.base);
    configData.vocabularies.forEach(function (voc) {
        if (configData) {
            var vocFilename = fileList_1[config_file_factory_1.ConfigFileFactory.getFilenameSource(voc).toUpperCase()];
            var outPath = "".concat(outputFolder_1, "/").concat(config_file_factory_1.ConfigFileFactory.getFilenameTarget(voc));
            var header = "".concat(stoutBase_1, "/").concat(voc.id, "/>. \n\n");
            var baseUrl = 'n0:';
            var footer_1 = '';
            // check if there is more than one lang
            var numLang = configData.title.length;
            var mainTitle = '';
            var creator = '';
            mainTitle = "".concat(mainTitle, "\"").concat(configData.title[0].value, " - ").concat(voc.title[0].value, "\"@").concat(voc.title[0].lang);
            creator = "".concat(creator, "\"").concat(configData.creator, "\"@").concat(voc.title[0].lang);
            if (numLang > 1) {
                mainTitle = "".concat(mainTitle, ",\n\t\"").concat(configData.title[1].value, " - ").concat(voc.title[1].value, "\"@").concat(voc.title[1].lang, ";\n");
                creator = "".concat(creator, ",\n\t\"").concat(configData.creator, "\"@").concat(voc.title[1].lang, ";\n");
            }
            else {
                creator = "".concat(creator, ";\n");
                mainTitle = "".concat(mainTitle, ";\n");
            }
            if (voc.description[0].value === '') {
                footer_1 = "".concat(baseUrl, "\n") +
                    '\ta skos:ConceptScheme;\n' +
                    "\tdct:creator ".concat(creator) +
                    "\tdct:title ".concat(mainTitle) +
                    "\tdc:title ".concat(mainTitle) +
                    "\tdc:description ".concat(mainTitle) +
                    '\tskos:hasTopConcept';
            }
            else {
                var mainDescription = '';
                for (var i = 0; i < numLang - 1; i++) {
                    mainDescription = "".concat(mainDescription, "\"").concat(voc.description[i].value, "\"@").concat(voc.description[i].lang, ",\n\t");
                }
                mainDescription = "".concat(mainDescription, "\"").concat(voc.description[numLang - 1].value) +
                    "\"@".concat(voc.description[numLang - 1].lang, ";\n");
                footer_1 = "".concat(baseUrl, "\n") +
                    '\ta skos:ConceptScheme;\n' +
                    "\tdct:creator ".concat(creator) +
                    "\tdct:title ".concat(mainTitle) +
                    "\tdct:description ".concat(mainDescription) +
                    '\tskos:hasTopConcept';
            }
            var stout = header;
            if (vocFilename) {
                var data = csv_factory_1.CsvFactory.load(vocFilename, csvDelimiter_1, false);
                if (data && data.length > 0) {
                    console.log("Processing '".concat(vocFilename, "': ").concat(data.length, " records found"));
                    // initiation of variables for loop:
                    var urlStack = [];
                    var nodesStack = [];
                    var bodyStack = [];
                    var nodeNodesStack = [];
                    var oldUrl = baseUrl;
                    var num = data.length;
                    urlStack.push(baseUrl);
                    for (var i = 0; i < num; i++) {
                        var d = data[i];
                        var deep = getNotationDeep(d.notation.toString().trim());
                        var deepNext = deep;
                        // check the deep of the next record
                        if ((i + 1) < num) {
                            var s = data[i + 1];
                            deepNext = getNotationDeep(s.notation.toString().trim());
                        }
                        else {
                            deepNext = 1;
                        }
                        oldUrl = urlStack[urlStack.length - 1];
                        var newUrl = "n0:".concat(d.id);
                        if (deepNext === deep || deepNext < deep) {
                            var body = "".concat(newUrl, "\n");
                            var prefLabel = '';
                            prefLabel = "".concat(prefLabel, "\"").concat(d.title, "\"@").concat(voc.title[0].lang);
                            if (numLang > 1) {
                                prefLabel = "".concat(prefLabel, ",\n\t\"").concat(d.title_en, "\"@").concat(voc.title[1].lang);
                            }
                            if (oldUrl === baseUrl) {
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:topConceptOf ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel ".concat(prefLabel);
                            }
                            else {
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:broader ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel ".concat(prefLabel);
                            }
                            if (d.description !== '') {
                                var desc = '';
                                desc = "".concat(desc, "\"").concat(d.description, "\"@").concat(voc.title[0].lang);
                                if (d.description_en !== '' && numLang > 1) {
                                    desc = "".concat(desc, ",\n\t\"").concat(d.description_en, "\"@").concat(voc.title[1].lang);
                                }
                                body = "".concat(body, "; \n\tskos:definition ").concat(desc, ".\n");
                            }
                            else
                                body = "".concat(body, ".\n");
                            nodesStack.push(newUrl);
                            stout = "".concat(stout).concat(body);
                            // In this case I have to write out the father with the nodesStack
                            if (deepNext < deep) {
                                nodeNodesStack.push(nodesStack);
                                var dif = deep - deepNext;
                                var _loop_1 = function () {
                                    urlStack.pop();
                                    var oldBody = bodyStack.pop();
                                    var tempNodesStack = nodeNodesStack.pop();
                                    if (tempNodesStack !== undefined) {
                                        oldBody = "".concat(oldBody, ";\n") +
                                            '\tskos:narrower ';
                                        tempNodesStack.forEach(function (node) {
                                            oldBody = "".concat(oldBody, "\n\t\t").concat(node, ",");
                                        });
                                        oldBody = oldBody === null || oldBody === void 0 ? void 0 : oldBody.replace(/.$/, '.');
                                        stout = "".concat(stout).concat(oldBody, "\n");
                                    }
                                    dif -= 1;
                                };
                                while (dif > 0) {
                                    _loop_1();
                                }
                                nodesStack = nodeNodesStack.pop();
                            }
                        }
                        else { /* If the deep of the next more than me. Actions:
                                                1. Store body of myself
                                                2. Store the actual nodesStack at nodeNodesStack
                                                3. Store the actual father
                                                4. Empty the nodesStack
                                                5. Store the actual deep
                                            */
                            var body = "".concat(newUrl, "\n");
                            var prefLabel = '';
                            prefLabel = "".concat(prefLabel, "\"").concat(d.title, "\"@").concat(voc.title[0].lang);
                            if (numLang > 1) {
                                prefLabel = "".concat(prefLabel, ",\n\t\"").concat(d.title_en, "\"@").concat(voc.title[1].lang);
                            }
                            if (oldUrl === baseUrl) {
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(oldUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:topConceptOf ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel ".concat(prefLabel);
                            }
                            else {
                                body = "".concat(body, "\t a skos:Concept;\n") +
                                    "\tskos:inScheme ".concat(baseUrl, ";\n") +
                                    "\tskos:notation \"".concat(d.notation, "\";\n") +
                                    "\tskos:broader ".concat(oldUrl, ";\n") +
                                    "\tskos:prefLabel ".concat(prefLabel);
                            }
                            if (d.description !== '') {
                                var desc = '';
                                desc = "".concat(desc, "\"").concat(d.description, "\"@").concat(voc.title[0].lang);
                                if (d.description_en !== '' && numLang > 1) {
                                    desc = "".concat(desc, ",\n\t\"").concat(d.description_en, "\"@").concat(voc.title[1].lang);
                                }
                                body = "".concat(body, "; \n\tskos:definition ").concat(desc);
                            }
                            bodyStack.push(body);
                            nodesStack.push(newUrl);
                            nodeNodesStack.push(nodesStack);
                            nodesStack = [];
                            urlStack.push(newUrl);
                        }
                    }
                    nodesStack.forEach(function (node) {
                        footer_1 = "".concat(footer_1, "\n\t\t").concat(node, ",");
                    });
                    footer_1 = footer_1.replace(/.$/, '.');
                    stout = "".concat(stout).concat(footer_1);
                    fs.writeFileSync(outPath, stout, { encoding: 'utf8' });
                }
                else {
                    console.log("\u001B[0;33mWARNING\u001B[0m Errors in file '".concat(vocFilename, "' - ignore"));
                }
            }
            else {
                console.log("\u001B[0;33mWARNING\u001B[0m file '".concat(dataFolder, "/").concat(voc.id, ".csv' not found - ignore"));
            }
        }
    });
}
//# sourceMappingURL=csv2ttl.js.map
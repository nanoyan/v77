"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CsvFactory = void 0;
var sync_1 = require("csv-parse/sync");
var plainjs_1 = require("@json2csv/plainjs");
var fs = require("fs");
require('fs');
function validHierarchy(notationCheckList, newString) {
    if (notationCheckList.length > 0) {
        var lastString = notationCheckList[notationCheckList.length - 1];
        var stringList = lastString.split('.');
        var newStringList = newString.split('.');
        var lastLevels = (lastString.split('.')).length;
        var newLevels = (newString.split('.')).length;
        if (lastLevels === newLevels) { // Same level
            return Number(stringList[lastLevels - 1]) < Number(newStringList[lastLevels - 1]);
        }
        if (lastLevels < newLevels) { // Deeper level
            return newLevels <= (lastLevels + 1);
        } // Superficial level
        return Number(stringList[newLevels - 1]) < Number(newStringList[newLevels - 1]);
    }
    return true;
}
var CsvFactory = /** @class */ (function () {
    function CsvFactory() {
    }
    CsvFactory.load = function (dataFilename, csvDelimiter, allowEmptyId) {
        var csvData = null;
        if (fs.existsSync(dataFilename)) {
            try {
                var csvDataRaw = fs.readFileSync(dataFilename, 'utf8');
                csvData = (0, sync_1.parse)(csvDataRaw, {
                    columns: true,
                    skip_empty_lines: true,
                    delimiter: csvDelimiter
                });
            }
            catch (err) {
                console.log("\u001B[0;31mERROR\u001B[0m reading and parsing data file '".concat(dataFilename, "':"));
                console.error(err);
                csvData = null;
                process.exitCode = 1;
            }
            if (csvData) {
                var uniqueIdList_1 = [];
                var uniqueTitleList_1 = [];
                var uniqueNotationList_1 = [];
                var uniqueIdErrors_1 = [];
                var uniqueTitleErrors_1 = [];
                var uniqueNotationErrors_1 = [];
                var validHierarchyErrors_1 = [];
                var fatalError = false;
                var recordNumber_1 = 1;
                var notationPattern_1 = /^(([1-9][0-9]*)(\.[1-9][0-9]*)*)$|^([a-zA-Z]*)$/;
                var numericPattern_1 = /^(([1-9][0-9]*)(\.[1-9][0-9]*)*)$/;
                var specialPattern_1 = /^([A-Z]+)(\s([0-9]([0-9]*)*(\.[0-9]([0-9]*))*)*)$/;
                csvData.forEach(function (c) {
                    recordNumber_1 += 1;
                    if (c.id) {
                        if (uniqueIdList_1.includes(c.id)) {
                            uniqueIdErrors_1.push("#".concat(recordNumber_1));
                        }
                        else {
                            uniqueIdList_1.push(c.id);
                        }
                    }
                    else if (!allowEmptyId) {
                        uniqueIdErrors_1.push("#".concat(recordNumber_1));
                    }
                    if (c.notation) {
                        var notationMatches = c.notation.match(notationPattern_1);
                        var numericMatches = c.notation.match(numericPattern_1);
                        var specialMatches = c.notation.match(specialPattern_1);
                        if (numericMatches) {
                            if (!validHierarchy(uniqueNotationList_1, c.notation)) {
                                validHierarchyErrors_1.push("#".concat(recordNumber_1));
                            }
                        }
                        if (specialMatches || notationMatches) {
                            if (uniqueNotationList_1.includes(c.notation)) {
                                uniqueNotationErrors_1.push("#".concat(recordNumber_1));
                            }
                            else {
                                uniqueNotationList_1.push(c.notation);
                            }
                        }
                        else {
                            uniqueNotationErrors_1.push("#".concat(recordNumber_1));
                        }
                        // TO DO specialMatches check for validHierarchy replaying each character for a number before
                    }
                    if (c.title) {
                        var checkTitleExpression = "".concat(c.notation || '', "-").concat(c.title);
                        if (uniqueTitleList_1.includes(checkTitleExpression)) {
                            uniqueTitleErrors_1.push("#".concat(recordNumber_1));
                        }
                        else {
                            uniqueTitleList_1.push(checkTitleExpression);
                        }
                    }
                    else {
                        uniqueTitleErrors_1.push("#".concat(recordNumber_1));
                    }
                });
                var allNotations = csvData.map(function (c) { return c.notation; }).filter(function (n) { return n && n.length > 0; });
                if (allNotations.length > 0) {
                    if (allNotations.length < csvData.length) {
                        console.log("\u001B[0;31mERROR\u001B[0m Notations must be given all or none in data file '".concat(dataFilename, "'"));
                        fatalError = true;
                    }
                    if (uniqueNotationErrors_1.length > 0) {
                        console.log("\u001B[0;31mERROR\u001B[0m Notations must be unique and valid in data file '".concat(dataFilename, "'") +
                            "(".concat(uniqueNotationErrors_1.join(', '), ")"));
                        fatalError = true;
                    }
                }
                if (uniqueTitleErrors_1.length > 0) {
                    console.log("\u001B[0;31mERROR\u001B[0m Titles must be unique and not empty in data file '".concat(dataFilename, "'") +
                        "(".concat(uniqueTitleErrors_1.join(', '), ")"));
                    fatalError = true;
                }
                if (uniqueIdErrors_1.length > 0) {
                    if (allowEmptyId) {
                        console.log("\u001B[0;31mERROR\u001B[0m IDs must be unique in data file '".concat(dataFilename, "'") +
                            "(".concat(uniqueIdErrors_1.join(', '), ")"));
                    }
                    else {
                        console.log("\u001B[0;31mERROR\u001B[0m IDs must be unique and not empty in data file '".concat(dataFilename, "'") +
                            "(".concat(uniqueIdErrors_1.join(', '), ")"));
                    }
                    fatalError = true;
                }
                if (validHierarchyErrors_1.length > 0) {
                    console.log('\x1b[0;31mERROR\x1b[0m Notations must be bigger than the prior notation and' +
                        'also can not increase the number of levels from the prior record to next by more than one level.\'' +
                        " ".concat(dataFilename, "' (").concat(validHierarchyErrors_1.join(', '), ")"));
                    fatalError = true;
                }
                if (fatalError) {
                    csvData = null;
                    process.exitCode = 1;
                }
            }
        }
        else {
            console.log("\u001B[0;31mERROR\u001B[0m data file '".concat(dataFilename, "' not found"));
            process.exitCode = 1;
        }
        return csvData;
    };
    CsvFactory.write = function (dataFilename, data, csvDelimiter) {
        var returnValue = true;
        // eslint-disable-next-line new-cap
        var parser = new plainjs_1.Parser({
            fields: ['notation', 'title', 'description', 'id', 'title_en', 'description_en'],
            quote: '',
            delimiter: csvDelimiter
        });
        try {
            var fileContent = parser.parse(data);
            fs.writeFileSync(dataFilename, fileContent);
        }
        catch (err) {
            console.log("\u001B[0;31mERROR\u001B[0m unable to write data file '".concat(dataFilename, "':"));
            console.error(err);
            returnValue = false;
            process.exitCode = 1;
        }
        return returnValue;
    };
    return CsvFactory;
}());
exports.CsvFactory = CsvFactory;
//# sourceMappingURL=csv.factory.js.map